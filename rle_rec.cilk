#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

#ifdef NO_CILK
#define spawn
#define cilk
#define sync
#endif

struct rle_node {
	char   symbol;
	unsigned long freq;
	struct rle_node *next;
};

struct rle_head {
	struct rle_node *first, *last;
};

static unsigned rle_rec_limit = 1;

struct rle_head *
rle_head_alloc(void)
{
	struct rle_head *ret;

	ret = malloc(sizeof(struct rle_head));
	if (ret == NULL) {
		fprintf(stderr, "%s: malloc failed\n", __FUNCTION__);
		exit(1);
	}

	return ret;
}

struct rle_node *
rle_alloc(void)
{
	struct rle_node *rle;

	rle = malloc(sizeof(struct rle_node));
	if (rle == NULL){
		fprintf(stderr, "%s: malloc failed\n", __FUNCTION__);
		exit(1);
	}

	return rle;
}

void
rle_print(struct rle_head *rle_head)
{
	struct rle_node *rle = rle_head->first;
	while (rle != NULL){
		printf("(`%c': %4ld) ", rle->symbol, rle->freq);
		rle = rle->next;
	}
	printf("\n");
}


struct rle_head *
rle_mkrand(unsigned long rle_nr, unsigned long *syms_nr)
{
	unsigned long i, syms_cnt = 0;
	struct rle_head *ret;
	struct rle_node *rle=NULL, dummy_head, *prev;
	const int max_freq = 100;
	const int min_freq = 1;

	dummy_head.next = NULL;
	prev = &dummy_head;
	for (i=0; i<rle_nr; i++) {
		rle = rle_alloc();
		prev->next = rle;

		rle->symbol = 'a' + (i % 26);
		rle->freq = min_freq + (rand() % (max_freq - min_freq +1));
		rle->next = NULL;
		syms_cnt += rle->freq;

		prev = rle;
	}

	if (syms_nr != NULL)
		*syms_nr = syms_cnt;

	ret = rle_head_alloc();
	ret->first = dummy_head.next;
	ret->last = rle;
	return ret;
}

char *
rle_decode(struct rle_head *rle_head, unsigned long syms_nr)
{
	char *ret;
	unsigned long i, syms_i;
	struct rle_node *rle;

	ret = malloc(syms_nr*sizeof(char));
	if (!ret){
		fprintf(stderr, "failed to allocate %lu bytes\n", syms_nr*sizeof(char));
		exit(1);
	}

	rle = rle_head->first;
	syms_i = 0;
	while (rle != NULL){
		for (i=0; i<rle->freq; i++)
			ret[syms_i++] = rle->symbol;
		rle = rle->next;
	}

	assert(syms_i == syms_nr);
	return ret;
}

struct rle_node *
rle_alloc_init(char symbol, unsigned long freq, struct rle_node *next)
{
	struct rle_node *rle;

	rle = rle_alloc();
	rle->symbol = symbol;
	rle->freq = freq;

	return rle;
}

struct rle_head *
rle_encode(char *symbols, unsigned long syms_nr)
{
	unsigned long i, freq;
	char prev;
	struct rle_head *ret;
	struct rle_node dummy_head, *node, *n;

	if (symbols == NULL || syms_nr == 0)
		return NULL;

	dummy_head.next = NULL;
	node = &dummy_head;

	prev = symbols[0];
	freq = 1;
	for (i=1; i<syms_nr; i++) {

		if (symbols[i] == prev){
			freq++;
			continue;
		}

		n = rle_alloc_init(prev, freq, NULL);

		node->next = n;
		node = n;
		prev = symbols[i];
		freq = 1;
	}

	n = rle_alloc_init(prev, freq, NULL);
	node->next = n;

	assert(dummy_head.next != NULL);

	ret = rle_head_alloc();
	ret->first = dummy_head.next;
	ret->last = n;
	return ret;
}

struct rle_head *
rle_merge(struct rle_head *rle1, struct rle_head *rle2)
{
	struct rle_node *rle1_last, *rle2_first;

	rle1_last = rle1->last;
	rle2_first = rle2->first;
	if (rle1_last->symbol == rle2_first->symbol){
		rle1_last->freq += rle2_first->freq;
		rle1_last->next = rle2_first->next;
		if (rle2->last != rle2_first)
			rle1->last = rle2->last;
		free(rle2_first);
	} else {
		rle1_last->next = rle2_first;
		rle1->last = rle2->last;
	}

	free(rle2);
	return rle1;
}

cilk struct rle_head *
rle_encode_rec(char *symbols, unsigned long syms_nr)
{
	unsigned long syms_nr1, syms_nr2;
	struct rle_head *rle1, *rle2;

	if (syms_nr == 0 || symbols == NULL)
		return NULL;

	/* unitary solution */
	#if 0
	if (syms_nr == 1){
		ret = malloc(sizeof(struct rle_head));
		ret->first = ret->last = rle_alloc_init(symbols[0], 1, NULL);
		return ret;
	}
	#endif
	if (syms_nr <= rle_rec_limit){
		return rle_encode(symbols, syms_nr);
	}

	/* binary splitting */
	syms_nr1 = syms_nr / 2;
	syms_nr2 = syms_nr - syms_nr1;
	rle1 = spawn rle_encode_rec(symbols, syms_nr1);
	rle2 = spawn rle_encode_rec(symbols + syms_nr1, syms_nr2);
	sync;

	/* combining solutions */
	assert(rle1 != NULL && rle2 != NULL);
	return rle_merge(rle1, rle2);
}

int
rle_cmp(struct rle_head *rle1, struct rle_head *rle2)
{
	struct rle_node *r1, *r2;

	r1 = rle1->first;
	r2 = rle2->first;

	while (1) {
		if (r1 == NULL && r2 == NULL)
			return 1;

		if (r1 == NULL || r2 == NULL)
			return 0;

		if (r1->symbol != r2->symbol)
			return 0;

		if (r1->freq != r2->freq)
			return 0;

		r1 = r1->next;
		r2 = r2->next;
	}

	assert(0 && "Stupid compiler");
	return 0;
}

#include "timer.h"

cilk int
main(int argc, const char *argv[])
{
	struct rle_head *rle, *rle_new, *rle_rec;
	unsigned long syms_nr, rles_nr;
	char *symbols, *rle_rec_limit_str;
	xtimer_t t;

	if ( (rle_rec_limit_str = getenv("RLE_REC_LIMIT")) != NULL){
		rle_rec_limit = atol(rle_rec_limit_str);
		if (rle_rec_limit == 0)
			rle_rec_limit = 1;
	}

	rles_nr = 0;
	if (argc > 1)
		rles_nr = atol(argv[1]);
	if (rles_nr == 0)
		rles_nr = 10000000;

	srand(time(NULL));
	rle = rle_mkrand(rles_nr, &syms_nr);
	//rle_print(rle);

	printf("number of rles:%lu\n", rles_nr);
	printf("number of symbols:%lu\n", syms_nr);
	printf("rle_rec_limit:%u\n", rle_rec_limit);
	symbols = rle_decode(rle, syms_nr);

	timer_init(&t); timer_start(&t);
	rle_new = rle_encode(symbols, syms_nr);
	//rle_print(rle_new);
	timer_pause(&t); printf("rle_encode:     %lf secs\n", timer_secs(&t));
	assert(rle_cmp(rle, rle_new) == 1);
	sync;

	timer_init(&t); timer_start(&t);
	rle_rec = spawn rle_encode_rec(symbols, syms_nr);
	sync;
	timer_pause(&t); printf("rle_encode_rec: %lf secs\n", timer_secs(&t));
	//rle_print(rle_rec);
	assert(rle_cmp(rle, rle_rec) == 1);


	return 0;
}

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

/* paramemeter to stop recursion */
static unsigned rle_rec_limit = 64;

/* rle list node */
struct rle_node {
	char   symbol;
	unsigned long freq;
	struct rle_node *next;
};

/* head for rle list.
 * Keep two pointers: one to the last and one to the first element
 */
struct rle_head {
	struct rle_node *first, *last;
};



/* create a random rle list.
 *  - The list will contain rle_nr elements
 *  - Each element will have a different symbol and a random
 *    frequency between min_freq and max_freq
 *  - If syms_nr is not NULL, on return it will contain the total
 *    number of symbols
 */
struct rle_head *
rle_mkrand(unsigned long rle_nr, unsigned long *syms_nr, int min_freq, int max_freq)
{
	struct rle_head *ret;

	assert(min_freq < max_freq);

	ret = NULL;
	assert(0 && "I am empty!");
	return ret;

}

/* decode rle list with head rle_head.
 * The list contains syms_nr symbols.
 */
char *
rle_decode(struct rle_head *rle_head, unsigned long syms_nr)
{
	char *ret;

	ret = NULL;
	assert(0 && "I am empty!");
	return ret;
}

/* rle_encode:
 *  serial accumulator (non-recursive) rle encoding
 *   symbols : symbol buffer
 *   syms_nr : number of symbols (size of buffer)
 */
struct rle_head *
rle_encode(char *symbols, unsigned long syms_nr)
{
	struct rle_head *ret;

	ret = NULL;
	assert(0 && "I am empty!");
	return ret;
}

/*
 * rle_encode_rec:
 *  parallel recursive rle encoding
 *   symbols : symbol buffer
 *   syms_nr : number of symbols (size of buffer)
 */
cilk struct rle_head *
rle_encode_rec(char *symbols, unsigned long syms_nr)
{
	struct rle_head *ret;

	ret = NULL;
	assert(0 && "I am empty!");
	return ret;
}

/*
 * rle_equal:
 *  compare two rle lists:
 *  return 1 if they are equal.
 */
int
rle_equal(struct rle_head *rle1, struct rle_head *rle2)
{
	assert(0 && "I am empty!");
	return 0;
}

cilk int
main(int argc, const char *argv[])
{
	struct rle_head *rle, *rle_new, *rle_rec;
	unsigned long syms_nr, rles_nr;
	char  *symbols = NULL;


	/*
	 * get the following parameters from argv:
	 *  rles_nr:       number of rle elements to create
	 *  rle_rec_limit: recursion limit for rle encoding
	 */
	 rles_nr = 42;

	/* create random data */
	srand(time(NULL));
	rle = rle_mkrand(rles_nr, &syms_nr, 1, 100);

	/* decode */
	symbols = rle_decode(rle, syms_nr);

	/* serial accumulator encoding */
	rle_new = rle_encode(symbols, syms_nr);
	assert(rle_equal(rle, rle_new));

	/* parallel recursive encoding */
	rle_rec = spawn rle_encode_rec(symbols, syms_nr);
	sync;

	assert(rle_equal(rle, rle_rec));

	return 0;
}
